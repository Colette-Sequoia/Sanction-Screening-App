import { useState, useRef } from "react";
import Papa from "papaparse";
import * as XLSX from "xlsx";

// --- Load PDF.js dynamically ---
const loadPdfJs = () => new Promise((resolve, reject) => {
  if (window.pdfjsLib) return resolve(window.pdfjsLib);
  const script = document.createElement("script");
  script.src = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
  script.onload = () => {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    resolve(window.pdfjsLib);
  };
  script.onerror = reject;
  document.head.appendChild(script);
});

const extractPdfLines = async (file) => {
  const lib = await loadPdfJs();
  const buf = await file.arrayBuffer();
  const pdf = await lib.getDocument({ data: buf }).promise;
  const lines = [];
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    // Group items into lines by approximate Y position
    const byY = {};
    content.items.forEach(item => {
      const y = Math.round(item.transform[5]);
      if (!byY[y]) byY[y] = [];
      byY[y].push(item.str);
    });
    Object.keys(byY).sort((a, b) => b - a).forEach(y => {
      const line = byY[y].join(" ").trim();
      if (line) lines.push(line);
    });
  }
  return lines;
};

// --- Matching ---
const TITLES = /^(mr\.?\s+|mrs\.?\s+|ms\.?\s+|miss\.?\s+|dr\.?\s+|prof\.?\s+|sir\.?\s+|madam\.?\s+|mx\.?\s+|rev\.?\s+|hon\.?\s+|lord\.?\s+|lady\.?\s+)/i;

function normalizeName(name) {
  if (!name) return "";
  let s = String(name).trim().toLowerCase().replace(TITLES, "");
  return s.replace(/[^\w\s]/g, "").replace(/\s+/g, " ").trim();
}

function levenshtein(a, b) {
  const m = [], la = a.length, lb = b.length;
  for (let i = 0; i <= lb; i++) m[i] = [i];
  for (let j = 0; j <= la; j++) m[0][j] = j;
  for (let i = 1; i <= lb; i++)
    for (let j = 1; j <= la; j++)
      m[i][j] = b[i-1] === a[j-1] ? m[i-1][j-1] : Math.min(m[i-1][j-1]+1, m[i][j-1]+1, m[i-1][j]+1);
  return m[lb][la];
}

function simpleRatio(a, b) {
  if (a === b) return 100;
  if (!a.length || !b.length) return 0;
  const longer = Math.max(a.length, b.length);
  return Math.round(((longer - levenshtein(a, b)) / longer) * 100);
}

function tokenSetRatio(s1, s2) {
  const t1 = [...new Set(s1.split(/\s+/).filter(Boolean))];
  const t2 = [...new Set(s2.split(/\s+/).filter(Boolean))];
  if (!t1.length && !t2.length) return 100;
  if (!t1.length || !t2.length) return 0;
  const s1s = [...t1].sort().join(" "), s2s = [...t2].sort().join(" ");
  const inter = t1.filter(t => t2.includes(t));
  const base = simpleRatio(s1s, s2s);
  if (!inter.length) return base;
  const si = [...inter].sort().join(" ");
  return Math.max(base, simpleRatio(s1s, si), simpleRatio(s2s, si));
}

function matchScore(a, b) { return tokenSetRatio(normalizeName(a), normalizeName(b)); }

// --- File reading ---
function readStructuredFile(file, onRows, onError) {
  const ext = file.name.split(".").pop().toLowerCase();
  if (ext === "csv" || ext === "txt") {
    Papa.parse(file, {
      header: true, skipEmptyLines: true, dynamicTyping: false,
      complete: ({ data }) => onRows(data.map(r => { const o = {}; Object.keys(r).forEach(k => { o[k.trim()] = r[k]; }); return o; })),
      error: onError
    });
  } else {
    const reader = new FileReader();
    reader.onload = ev => {
      try {
        const wb = XLSX.read(ev.target.result, { type: "array" });
        onRows(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { defval: "" }));
      } catch { onError(); }
    };
    reader.readAsArrayBuffer(file);
  }
}

const UN_COL = "FullName";

const C = {
  navy: "#05263B", card: "#073855", bg: "#444647",
  white: "#ffffff", green: "#27ae60", red: "#ff6b6b", yellow: "#f39c12",
};

const btnStyle = (disabled) => ({
  background: disabled ? "#ccc" : C.white, color: disabled ? "#999" : C.navy,
  border: "none", borderRadius: 6, fontWeight: "bold",
  cursor: disabled ? "not-allowed" : "pointer", fontFamily: "Arial, sans-serif",
});

// PDF Preview Panel
function PdfPreview({ lines, onConfirm, onCancel }) {
  const [selected, setSelected] = useState(() => new Set(lines.map((_, i) => i)));
  const toggle = i => setSelected(prev => { const s = new Set(prev); s.has(i) ? s.delete(i) : s.add(i); return s; });
  const selectAll = () => setSelected(new Set(lines.map((_, i) => i)));
  const clearAll = () => setSelected(new Set());

  return (
    <div style={{ marginTop: 14, background: C.navy, borderRadius: 8, padding: 16 }}>
      <div style={{ fontSize: 14, fontWeight: "bold", marginBottom: 6 }}>
        üìÑ PDF Preview ‚Äî Select lines that are names
      </div>
      <div style={{ fontSize: 12, color: "#b0c4d8", marginBottom: 10 }}>
        {selected.size} of {lines.length} lines selected. Uncheck any lines that are not names (headers, page numbers, etc.)
      </div>
      <div style={{ display: "flex", gap: 8, marginBottom: 10 }}>
        <button onClick={selectAll} style={{ ...btnStyle(false), padding: "4px 12px", fontSize: 12 }}>Select All</button>
        <button onClick={clearAll} style={{ ...btnStyle(false), padding: "4px 12px", fontSize: 12 }}>Clear All</button>
      </div>
      <div style={{ background: C.card, borderRadius: 6, maxHeight: 220, overflowY: "auto", padding: 10, marginBottom: 12 }}>
        {lines.map((line, i) => (
          <div key={i} onClick={() => toggle(i)} style={{ display: "flex", alignItems: "center", gap: 8, padding: "4px 6px", borderRadius: 4, cursor: "pointer", background: selected.has(i) ? "rgba(255,255,255,0.08)" : "transparent", marginBottom: 2 }}>
            <div style={{ width: 16, height: 16, borderRadius: 3, border: `2px solid ${selected.has(i) ? C.green : "#555"}`, background: selected.has(i) ? C.green : "transparent", flexShrink: 0, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 11 }}>
              {selected.has(i) && "‚úì"}
            </div>
            <span style={{ fontSize: 13, color: selected.has(i) ? C.white : "#888" }}>{line}</span>
          </div>
        ))}
      </div>
      <div style={{ display: "flex", gap: 8 }}>
        <button onClick={() => onConfirm(lines.filter((_, i) => selected.has(i)))}
          style={{ ...btnStyle(selected.size === 0), padding: "8px 18px", fontSize: 13 }} disabled={selected.size === 0}>
          ‚úÖ Use Selected Lines ({selected.size})
        </button>
        <button onClick={onCancel} style={{ background: "transparent", border: `1px solid #555`, color: "#aaa", borderRadius: 6, padding: "8px 14px", fontSize: 13, cursor: "pointer" }}>
          Cancel
        </button>
      </div>
    </div>
  );
}

export default function App() {
  const [acknowledged, setAcknowledged] = useState(false);
  const [sanctionRows, setSanctionRows] = useState([]);
  const [sanctionHeaders, setSanctionHeaders] = useState([]);
  const [sanctionCol, setSanctionCol] = useState(UN_COL);
  const [sanctionFile, setSanctionFile] = useState("");
  const [sanctionPdfLines, setSanctionPdfLines] = useState(null);
  const [sanctionCount, setSanctionCount] = useState(0);

  const [clientRows, setClientRows] = useState([]);
  const [clientHeaders, setClientHeaders] = useState([]);
  const [clientCol, setClientCol] = useState(null);
  const [clientFile, setClientFile] = useState("");
  const [clientPdfLines, setClientPdfLines] = useState(null);
  const [clientPdfNames, setClientPdfNames] = useState([]);

  const [threshold, setThreshold] = useState(80);
  const [progress, setProgress] = useState(0);
  const [status, setStatus] = useState("Ready to process files");
  const [results, setResults] = useState(null);
  const [loading, setLoading] = useState(false);

  const unRef = useRef(), fileRef = useRef();

  // --- Sanctions file ---
  const applySanctionRows = (rows, col) => {
    const seen = new Set();
    const deduped = rows.filter(r => {
      const n = String(r[col] || "").trim().toLowerCase();
      if (!n || seen.has(n)) return false;
      seen.add(n); return true;
    });
    setSanctionRows(deduped);
    setSanctionCount(deduped.length);
    setStatus(`‚úÖ Reference data loaded: ${deduped.length} records`);
  };

  const handleSanction = async (e) => {
    const f = e.target.files[0]; if (!f) return;
    setSanctionFile(f.name); setSanctionRows([]); setSanctionHeaders([]);
    setSanctionPdfLines(null);
    const ext = f.name.split(".").pop().toLowerCase();
    if (ext === "pdf") {
      setStatus("Extracting text from PDF...");
      try {
        const lines = await extractPdfLines(f);
        setSanctionPdfLines(lines);
        setStatus(`PDF loaded ‚Äî ${lines.length} lines found. Review and confirm below.`);
      } catch { setStatus("‚ùå Failed to extract text from PDF. It may be a scanned image."); }
    } else {
      readStructuredFile(f, rows => {
        const headers = rows.length ? Object.keys(rows[0]) : [];
        setSanctionHeaders(headers);
        const col = headers.includes(UN_COL) ? UN_COL : headers[0];
        setSanctionCol(col);
        applySanctionRows(rows, col);
      }, () => setStatus("‚ùå Failed to parse file."));
    }
    e.target.value = "";
  };

  const confirmSanctionPdf = (lines) => {
    const rows = lines.map(l => ({ [UN_COL]: l }));
    setSanctionHeaders([UN_COL]);
    setSanctionCol(UN_COL);
    applySanctionRows(rows, UN_COL);
    setSanctionPdfLines(null);
  };

  // --- Client file ---
  const handleClient = async (e) => {
    const f = e.target.files[0]; if (!f) return;
    setClientFile(f.name); setClientRows([]); setClientHeaders([]); setClientCol(null);
    setClientPdfLines(null); setClientPdfNames([]);
    const ext = f.name.split(".").pop().toLowerCase();
    if (ext === "pdf") {
      setStatus("Extracting text from PDF...");
      try {
        const lines = await extractPdfLines(f);
        setClientPdfLines(lines);
        setStatus(`PDF loaded ‚Äî ${lines.length} lines found. Review and confirm below.`);
      } catch { setStatus("‚ùå Failed to extract text from PDF. It may be a scanned image."); }
    } else {
      readStructuredFile(f, rows => {
        setClientRows(rows);
        setClientHeaders(rows.length ? Object.keys(rows[0]) : []);
      }, () => setStatus("‚ùå Failed to parse file."));
    }
    e.target.value = "";
  };

  const confirmClientPdf = (lines) => {
    setClientPdfNames(lines);
    setClientPdfLines(null);
    setStatus(`‚úÖ ${lines.length} client names loaded from PDF`);
  };

  const applyClientCol = (col) => setClientCol(col);

  // Resolved client names (PDF or structured)
  const resolvedClientNames = clientPdfNames.length > 0
    ? clientPdfNames
    : clientRows.map(r => String(r[clientCol] || "").trim()).filter(Boolean);

  const sanctionReady = sanctionRows.length > 0;
  const clientReady = resolvedClientNames.length > 0;
  const canRun = sanctionReady && clientReady && !loading;

  const runScreening = () => {
    if (!canRun) return;
    setLoading(true); setResults(null); setProgress(0);
    setStatus("Processing files...");
    let p = 0;
    const interval = setInterval(() => { p = Math.min(p + 4, 90); setProgress(p); }, 80);
    setTimeout(() => {
      clearInterval(interval);
      const high = [], partial = [];

      // Dedupe sanctions by normalized name
      const sanctionMap = new Map();
      sanctionRows.forEach(sr => {
        const sn = String(sr[sanctionCol] || "").trim();
        if (!sn) return;
        const key = normalizeName(sn);
        if (!sanctionMap.has(key)) sanctionMap.set(key, sn);
      });
      const uniqueSanctions = [...sanctionMap.values()];

      // Dedupe clients
      const seenClients = new Set();
      const uniqueClients = resolvedClientNames.filter(name => {
        const key = normalizeName(name);
        if (!key || seenClients.has(key)) return false;
        seenClients.add(key); return true;
      });

      uniqueClients.forEach(name => {
        let best = 0, bestName = "";
        uniqueSanctions.forEach(sn => {
          const score = matchScore(name, sn);
          if (score > best) { best = score; bestName = sn; }
        });
        const entry = { clientName: name, matchedName: bestName, score: best };
        if (best >= threshold) high.push(entry);
        else if (best >= 50) partial.push(entry);
      });

      high.sort((a, b) => b.score - a.score);
      partial.sort((a, b) => b.score - a.score);
      setProgress(100);
      setResults({ high, partial, totalUN: uniqueSanctions.length, totalClients: uniqueClients.length });
      setStatus(`Completed ‚Äî ${high.length} high matches, ${partial.length} partial matches`);
      setLoading(false);
      setTimeout(() => setProgress(0), 1000);
    }, 200);
  };

  const exportXLSX = () => {
    if (!results) return;
    const rows = [["Type","Client Name","UN List Name","Score (%)"]];
    results.high.forEach(r => rows.push(["High Match", r.clientName, r.matchedName, r.score]));
    results.partial.forEach(r => rows.push(["Partial Match", r.clientName, r.matchedName, r.score]));
    const ws = XLSX.utils.aoa_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Screening Results");
    XLSX.writeFile(wb, `sanction_screening_results_${new Date().toISOString().slice(0,10)}.xlsx`);
  };

  const riskColor = score => score >= threshold ? C.green : score >= 70 ? C.yellow : C.red;

  const card = (children) => (
    <div style={{ background: C.card, border: `2px solid ${C.navy}`, borderRadius: 8, padding: 20, marginBottom: 20 }}>{children}</div>
  );

  const cardTitle = (step, text) => (
    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 10 }}>
      <div style={{ background: C.white, color: C.navy, borderRadius: "50%", width: 26, height: 26, display: "flex", alignItems: "center", justifyContent: "center", fontSize: 13, fontWeight: 800, flexShrink: 0 }}>{step}</div>
      <div style={{ fontSize: 18, fontWeight: "bold", color: C.white }}>{text}</div>
    </div>
  );

  const colPicker = (headers, selected, onSelect, label) => (
    <div style={{ marginTop: 12, padding: "12px 14px", background: C.navy, borderRadius: 6 }}>
      <div style={{ fontSize: 12, fontWeight: "bold", color: C.white, marginBottom: 8 }}>{label}</div>
      <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
        {headers.map(h => {
          const isSelected = selected === h;
          return (
            <button key={h} onClick={() => onSelect(h)} style={{
              padding: "6px 14px", fontSize: 12, fontWeight: isSelected ? 800 : 400,
              border: "none", borderRadius: 6, cursor: "pointer", fontFamily: "Arial, sans-serif",
              background: isSelected ? C.green : "rgba(255,255,255,0.12)",
              color: isSelected ? C.white : "#ccc",
              boxShadow: isSelected ? `0 0 0 2px ${C.white}` : "none",
              transition: "all 0.15s ease",
              letterSpacing: isSelected ? 0.3 : 0,
            }}>
              {isSelected ? `‚úì ${h}` : h}
            </button>
          );
        })}
      </div>
    </div>
  );

  const browseRow = (label, ref, onChange, fileName, accept) => (
    <div style={{ display: "flex", alignItems: "center", gap: 10, marginBottom: 10 }}>
      <div style={{ background: C.navy, padding: "8px 15px", borderRadius: 6, flex: 1, textAlign: "center", fontSize: 14 }}>
        {fileName || label}
      </div>
      <label style={{ ...btnStyle(false), padding: "8px 16px", cursor: "pointer", fontSize: 14 }}>
        Browse
        <input ref={ref} type="file" accept={accept} onChange={onChange} style={{ display: "none" }} />
      </label>
    </div>
  );

  return (
    <div style={{ fontFamily: "Arial, sans-serif", background: C.bg, minHeight: "100vh", padding: 20, color: C.white }}>

      {/* Disclaimer Modal */}
      {!acknowledged && (
        <div style={{ position: "fixed", inset: 0, background: "rgba(0,0,0,0.85)", zIndex: 1000, display: "flex", alignItems: "center", justifyContent: "center", padding: 20 }}>
          <div style={{ background: C.navy, border: `2px solid ${C.card}`, borderRadius: 12, maxWidth: 680, width: "100%", maxHeight: "90vh", display: "flex", flexDirection: "column", overflow: "hidden" }}>
            {/* Modal Header */}
            <div style={{ background: C.card, padding: "18px 24px", borderBottom: `2px solid ${C.navy}`, flexShrink: 0 }}>
              <div style={{ fontSize: 20, fontWeight: "bold", color: C.white, marginBottom: 4 }}>Disclaimer & Terms of Use</div>
              <div style={{ fontSize: 12, color: "#b0c4d8" }}>Sequoia Investment Solutions ‚Äì Sanctions Screening Application</div>
            </div>

            {/* Scrollable Content */}
            <div style={{ overflowY: "auto", padding: "20px 24px", flex: 1 }}>
              {[
                {
                  title: "1. General Disclaimer",
                  body: "This Sanctions Screening Application is provided by Sequoia Investment Solutions strictly as an internal decision-support tool. It is designed to assist compliance personnel in identifying potential matches between client names and the UN Consolidated Sanctions List. It is not intended to serve as a definitive compliance determination, legal advice, or a substitute for professional judgment."
                },
                {
                  title: "2. No Warranty on Results",
                  body: "Sequoia Investment Solutions makes no representations, warranties, or guarantees regarding the accuracy, completeness, or reliability of the results produced by this App. The fuzzy-matching algorithm is probabilistic and may produce false positives or false negatives. Sequoia Investment Solutions accepts no responsibility or liability for any errors, omissions, or inaccuracies in the screening results."
                },
                {
                  title: "3. No Legal or Compliance Advice",
                  body: "Nothing produced by this App constitutes legal advice or a formal compliance opinion. All results must be reviewed and verified by a suitably qualified compliance officer or legal professional, and cross-referenced against the most current official sanctions lists. Users are solely responsible for ensuring compliance with all applicable laws and regulations, including those administered by the UN Security Council, FATF, FIC, and SARB."
                },
                {
                  title: "4. Data Accuracy & Currency",
                  body: "The accuracy of results depends entirely on the quality and currency of data uploaded by the User. Sequoia Investment Solutions does not automatically update or verify the sanctions list data used within the App and is not responsible for consequences arising from the use of outdated or incorrectly formatted data."
                },
                {
                  title: "5. Limitation of Liability",
                  body: "To the fullest extent permitted by applicable law, Sequoia Investment Solutions, its directors, officers, employees, and agents shall not be liable for any direct, indirect, incidental, or consequential damages arising from use of this App, including any regulatory action, penalty, reputational harm, or financial loss howsoever caused."
                },
                {
                  title: "6. User Responsibility",
                  body: "By acknowledging this disclaimer, you confirm that you are an authorised user, that you will not make compliance or business decisions based solely on the output of this App without independent verification, and that you accept full responsibility for any decisions or actions taken based on the App's results."
                },
                {
                  title: "7. Data Privacy (POPIA)",
                  body: "All client data uploaded must be handled in accordance with the Protection of Personal Information Act 4 of 2013 (POPIA). All processing occurs locally within your browser session. Sequoia Investment Solutions does not store, transmit, or have access to any data uploaded through this App."
                },
                {
                  title: "8. Governing Law",
                  body: "This disclaimer is governed by the laws of the Republic of South Africa. Any disputes shall be subject to the exclusive jurisdiction of the South African courts."
                },
              ].map(s => (
                <div key={s.title} style={{ marginBottom: 16 }}>
                  <div style={{ fontWeight: "bold", fontSize: 13, color: C.white, marginBottom: 4 }}>{s.title}</div>
                  <div style={{ fontSize: 12.5, color: "#b0c4d8", lineHeight: 1.65 }}>{s.body}</div>
                </div>
              ))}
              <div style={{ fontSize: 11.5, color: "#7a95a8", borderTop: `1px solid ${C.card}`, paddingTop: 12, marginTop: 4 }}>
                Last Updated: February 2026 &nbsp;¬∑&nbsp; ¬© 2026 Sequoia Investment Solutions. All rights reserved.
              </div>
            </div>

            {/* Footer */}
            <div style={{ background: C.card, padding: "16px 24px", borderTop: `2px solid ${C.navy}`, flexShrink: 0 }}>
              <div style={{ fontSize: 12, color: "#b0c4d8", marginBottom: 12 }}>
                By clicking <strong>"I Acknowledge & Accept"</strong> below, you confirm that you have read, understood, and agree to the terms of this disclaimer.
              </div>
              <button onClick={() => setAcknowledged(true)}
                style={{ background: C.green, color: C.white, border: "none", borderRadius: 6, padding: "11px 28px", fontWeight: "bold", fontSize: 14, cursor: "pointer", width: "100%", fontFamily: "Arial, sans-serif" }}>
                I Acknowledge & Accept
              </button>
            </div>
          </div>
        </div>
      )}

      <div style={{ maxWidth: 1000, margin: "0 auto", background: C.navy, borderRadius: 12, overflow: "hidden" }}>

        <div style={{ background: C.navy, padding: 20, textAlign: "center", borderBottom: `2px solid ${C.card}` }}>
          <div style={{ fontSize: 28, fontWeight: "bold", color: C.white }}>Sanction Screening</div>
        </div>

        <div style={{ padding: 20 }}>

          {/* Step 1 ‚Äî Sanctions */}
          {card(<>
            {cardTitle("1", "Upload UN Sanctions List")}
            <div style={{ fontSize: 13, color: "#b0c4d8", marginBottom: 14 }}>
              Upload the UN Consolidated Sanctions List as a <strong>CSV</strong>, <strong>XLSX</strong>, or <strong>PDF</strong> file. The app will automatically use the <strong>"FullName"</strong> column for spreadsheets. PDF files will show a line preview for you to confirm the name entries.
            </div>
            {browseRow("No reference file selected", unRef, handleSanction, sanctionFile, ".xlsx,.xls,.csv,.pdf")}
            {sanctionRows.length > 0 && (
              <div style={{ fontSize: 12, color: C.green, marginBottom: 6 }}>‚úÖ {sanctionCount.toLocaleString()} records loaded</div>
            )}
            {sanctionPdfLines && (
              <PdfPreview lines={sanctionPdfLines} onConfirm={confirmSanctionPdf} onCancel={() => { setSanctionPdfLines(null); setSanctionFile(""); }} />
            )}
            {sanctionHeaders.length > 1 && !sanctionPdfLines && colPicker(sanctionHeaders, sanctionCol, col => {
              setSanctionCol(col);
              applySanctionRows(sanctionRows, col);
            }, `Name column ‚Äî currently: "${sanctionCol}"`)}
          </>)}

          {/* Step 2 ‚Äî Clients */}
          {card(<>
            {cardTitle("2", "Upload Client List to Screen")}
            <div style={{ fontSize: 13, color: "#b0c4d8", marginBottom: 14 }}>
              Upload any <strong>CSV</strong>, <strong>XLSX</strong>, or <strong>PDF</strong> file containing your client names. For spreadsheets, select the column that contains the names after uploading. For PDFs, review the extracted lines and confirm which ones are names.
            </div>
            {browseRow("No file selected", fileRef, handleClient, clientFile, ".xlsx,.xls,.csv,.pdf")}
            {clientPdfLines && (
              <PdfPreview lines={clientPdfLines} onConfirm={confirmClientPdf} onCancel={() => { setClientPdfLines(null); setClientFile(""); }} />
            )}
            {clientPdfNames.length > 0 && (
              <div style={{ fontSize: 12, color: C.green, marginBottom: 6 }}>‚úÖ {clientPdfNames.length} names loaded from PDF</div>
            )}
            {clientHeaders.length > 0 && !clientCol && !clientPdfLines && (
              <div style={{ background: "#7a4f00", padding: "12px 14px", borderRadius: 6, marginTop: 10 }}>
                <div style={{ fontSize: 13, fontWeight: "bold", marginBottom: 8 }}>üëÜ Select the column containing client names:</div>
                <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
                  {clientHeaders.map(h => (
                    <button key={h} onClick={() => applyClientCol(h)} style={{ ...btnStyle(false), padding: "5px 14px", fontSize: 12 }}>{h}</button>
                  ))}
                </div>
              </div>
            )}
            {clientHeaders.length > 0 && clientCol && colPicker(clientHeaders, clientCol, applyClientCol, `Name column ‚Äî currently: "${clientCol}" (${clientRows.length} records)`)}
          </>)}

          {/* Step 3 ‚Äî Settings */}
          {card(<>
            {cardTitle("3", "Configure & Run")}
            <div style={{ fontSize: 13, color: "#b0c4d8", marginBottom: 14 }}>
              Set your match threshold ‚Äî names scoring at or above this percentage will be flagged as <strong>High Matches</strong>. Lower the threshold to catch more potential matches; raise it for stricter results.
            </div>
            <div style={{ display: "flex", alignItems: "center", gap: 15 }}>
              <span>Match Threshold:</span>
              <input type="range" min={50} max={100} value={threshold} onChange={e => setThreshold(+e.target.value)}
                style={{ flex: 1, height: 6, accentColor: C.white, cursor: "pointer" }} />
              <div style={{ background: C.white, color: C.navy, padding: "5px 12px", borderRadius: 4, fontWeight: "bold", minWidth: 54, textAlign: "center" }}>
                {threshold}%
              </div>
            </div>
          </>)}

          {/* Run */}
          <button onClick={runScreening} disabled={!canRun}
            style={{ ...btnStyle(!canRun), padding: "12px 25px", fontSize: 14, width: "auto", display: "block", margin: "0 auto 15px" }}>
            Compare Names
          </button>

          {/* Progress */}
          <div style={{ width: "100%", height: 8, background: "#e0e0e0", borderRadius: 4, overflow: "hidden", marginBottom: 10 }}>
            <div style={{ height: "100%", width: `${progress}%`, background: C.green, transition: "width 0.3s ease", borderRadius: 4 }} />
          </div>
          <div style={{ textAlign: "center", fontSize: 14, marginBottom: 10 }}>{status}</div>

          {/* Download */}
          <button onClick={exportXLSX} disabled={!results}
            style={{ ...btnStyle(!results), padding: "12px 25px", fontSize: 14, display: "block", margin: "0 auto 20px" }}>
            Download Results
          </button>

          {/* Results */}
          {card(<>
            {cardTitle("4", "Results")}
            {!results ? (
              <div style={{ background: C.white, color: C.navy, borderRadius: 6, padding: 15, minHeight: 200, fontFamily: "monospace", fontSize: 12 }}>
                Results will appear here after processing...
              </div>
            ) : (
              <>
                <div style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 10, marginBottom: 16 }}>
                  {[
                    { label: "High Matches", val: results.high.length, color: C.green },
                    { label: "Partial Matches", val: results.partial.length, color: C.yellow },
                    { label: "UN Records", val: results.totalUN.toLocaleString(), color: C.white },
                    { label: "Clients Screened", val: results.totalClients, color: C.white },
                  ].map(s => (
                    <div key={s.label} style={{ background: C.navy, borderRadius: 8, padding: "12px 10px", textAlign: "center" }}>
                      <div style={{ fontSize: 22, fontWeight: 800, color: s.color }}>{s.val}</div>
                      <div style={{ fontSize: 11, color: "#ccc", marginTop: 2 }}>{s.label}</div>
                    </div>
                  ))}
                </div>
                <div style={{ background: C.white, color: C.navy, borderRadius: 6, overflow: "hidden", maxHeight: 380, overflowY: "auto" }}>
                  <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 13 }}>
                    <thead style={{ position: "sticky", top: 0 }}>
                      <tr style={{ background: C.navy, color: C.white }}>
                        {["Type","Client Name","Best UN Match","Score"].map(h => (
                          <th key={h} style={{ padding: "10px 12px", textAlign: "left", fontWeight: 700, fontSize: 12, textTransform: "uppercase", letterSpacing: 0.4 }}>{h}</th>
                        ))}
                      </tr>
                    </thead>
                    <tbody>
                      {[...results.high, ...results.partial].map((r, i) => {
                        const isHigh = r.score >= threshold;
                        return (
                          <tr key={i} style={{ borderBottom: "1px solid #e0e0e0", background: i % 2 === 0 ? "#f9f9f9" : C.white }}>
                            <td style={{ padding: "10px 12px" }}>
                              <span style={{ background: isHigh ? "#d4edda" : "#fff3cd", color: isHigh ? "#155724" : "#856404", borderRadius: 4, padding: "2px 8px", fontSize: 11, fontWeight: 700 }}>
                                {isHigh ? "‚úÖ HIGH" : "üîç PARTIAL"}
                              </span>
                            </td>
                            <td style={{ padding: "10px 12px", fontWeight: 500 }}>{r.clientName}</td>
                            <td style={{ padding: "10px 12px", color: "#333" }}>{r.matchedName}</td>
                            <td style={{ padding: "10px 12px" }}>
                              <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                                <div style={{ height: 5, width: 60, background: "#e0e0e0", borderRadius: 3, overflow: "hidden" }}>
                                  <div style={{ height: "100%", width: `${r.score}%`, background: riskColor(r.score), borderRadius: 3 }} />
                                </div>
                                <span style={{ fontWeight: 700, color: riskColor(r.score), minWidth: 36 }}>{r.score}%</span>
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                      {results.high.length === 0 && results.partial.length === 0 && (
                        <tr><td colSpan={4} style={{ padding: 20, textAlign: "center", color: "#666" }}>No matches found above 50%</td></tr>
                      )}
                    </tbody>
                  </table>
                </div>
              </>
            )}
          </>)}
        </div>
      </div>
    </div>
  );
}
