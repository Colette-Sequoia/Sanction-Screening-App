<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sanction Screening App - Real Processing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #444647;
            color: white;
            padding: 20px;
        }
        
        .app-container {
            max-width: 1000px;
            margin: 0 auto;
            background: #05263B;
            border-radius: 12px;
            overflow: hidden;
        }
        
        .header {
            background: #05263B;
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid #073855;
        }
        
        .app-title {
            font-size: 28px;
            font-weight: bold;
            color: white;
            margin-bottom: 10px;
        }
        
        .logo {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 140px;
            height: 40px;
            background: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #05263B;
        }
        
        .main-content {
            padding: 20px;
        }
        
        .card {
            background: #073855;
            border: 2px solid #05263B;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .card-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: white;
        }
        
        .file-upload {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .file-label {
            background: #05263B;
            padding: 8px 15px;
            border-radius: 6px;
            flex: 1;
            text-align: center;
        }
        
        .browse-btn {
            background: white;
            color: #05263B;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .browse-btn:hover {
            background: #f0f0f0;
        }
        
        .threshold-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .threshold-slider {
            flex: 1;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .threshold-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .threshold-value {
            background: white;
            color: #05263B;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 50px;
            text-align: center;
        }
        
        .compare-btn {
            background: white;
            color: #05263B;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .compare-btn:hover {
            background: #f0f0f0;
        }
        
        .compare-btn:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: #27ae60;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status-text {
            text-align: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .download-btn {
            background: white;
            color: #05263B;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            margin: 10px auto;
            display: block;
        }
        
        .download-btn:hover {
            background: #f0f0f0;
        }
        
        .download-btn:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
        }
        
        .results-area {
            background: white;
            color: #05263B;
            border: 2px solid #05263B;
            border-radius: 6px;
            padding: 15px;
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .warning {
            background: #ff6b6b;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <div class="app-title">üîç Sanction Screening</div>
        </div>
        
        <div class="main-content">
            <!-- Reference Data Upload -->
            <div class="card">
                <div class="card-title">üìã Upload Reference Data</div>
                <div class="warning">‚ö†Ô∏è Please upload your reference data file (e.g., UN_List.xlsx)</div>
                <div class="file-upload">
                    <div class="file-label" id="unListLabel">No reference file selected</div>
                    <button class="browse-btn" onclick="selectUNList()">Browse</button>
                </div>
                <input type="file" id="unListInput" style="display: none;" accept=".xlsx,.xls,.csv">
                <div id="unListStatus" style="margin-top: 10px; font-size: 12px;"></div>
            </div>
            
            <!-- File Upload -->
            <div class="card">
                <div class="card-title">üìÅ Select File to Match</div>
                <div class="file-upload">
                    <div class="file-label" id="fileLabel">No file selected</div>
                    <button class="browse-btn" onclick="selectFile()">Browse</button>
                </div>
                <input type="file" id="fileInput" style="display: none;" accept=".xlsx,.xls,.csv">
            </div>
            
            <!-- Settings -->
            <div class="card">
                <div class="card-title">‚öôÔ∏è Settings</div>
                <div class="threshold-container">
                    <span>üéØ Match Threshold:</span>
                    <input type="range" class="threshold-slider" id="thresholdSlider" min="50" max="100" value="80">
                    <div class="threshold-value" id="thresholdValue">80%</div>
                </div>
            </div>
            
            <!-- Process Button -->
            <button class="compare-btn" id="compareBtn" onclick="processFiles()" disabled>üöÄ Compare Names</button>
            
            <!-- Progress -->
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="status-text" id="statusText">Ready to process files</div>
            
            <!-- Download Button -->
            <button class="download-btn" id="downloadBtn" onclick="downloadResults()" disabled>üíæ Download Results</button>
            
            <!-- Results -->
            <div class="card">
                <div class="card-title">üìä Results</div>
                <div class="results-area" id="resultsArea">
                    Results will appear here after processing...
                </div>
            </div>
        </div>
    </div>

    <script>
        let unListData = null;
        let fileData = null;
        let processingResults = null;
        
        // UN List selection
        function selectUNList() {
            document.getElementById('unListInput').click();
        }
        
        document.getElementById('unListInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('unListLabel').textContent = file.name;
                readExcelFile(file, 'reference');
            }
        });
        
        // File selection
        function selectFile() {
            document.getElementById('fileInput').click();
        }
        
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fileLabel').textContent = file.name;
                readExcelFile(file, 'file');
            }
        });
        
        // Read Excel file
        function readExcelFile(file, type) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    if (type === 'reference') {
                        unListData = jsonData;
                        document.getElementById('unListStatus').textContent = `‚úÖ Reference data loaded: ${jsonData.length} records`;
                        checkReadyState();
                    } else {
                        fileData = jsonData;
                        checkReadyState();
                    }
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading file. Please ensure it\'s a valid Excel file.');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Check if ready to process
        function checkReadyState() {
            const compareBtn = document.getElementById('compareBtn');
            if (unListData && fileData) {
                compareBtn.disabled = false;
                document.getElementById('statusText').textContent = 'Ready to process files';
            }
        }
        
        // Threshold slider
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdValue = document.getElementById('thresholdValue');
        
        thresholdSlider.addEventListener('input', function() {
            thresholdValue.textContent = this.value + '%';
        });
        
        // Normalize name function (JavaScript version of Python logic)
        function normalizeName(name) {
            if (!name) return "";
            
            let nameStr = String(name).trim().toLowerCase();
            
            // Remove common titles
            const titles = ['mr', 'mrs', 'ms', 'dr', 'prof', 'sir', 'madam', 'miss', 'mx'];
            const words = nameStr.split(' ');
            const filteredWords = words.filter(word => !titles.includes(word));
            nameStr = filteredWords.join(' ');
            
            // Remove special characters and normalize whitespace
            nameStr = nameStr.replace(/[^\w\s]/g, '');
            nameStr = nameStr.replace(/\s+/g, ' ').trim();
            
            return nameStr;
        }
        
        // Calculate similarity (enhanced fuzzy matching like Python's fuzzywuzzy)
        function calculateSimilarity(name1, name2) {
            const norm1 = normalizeName(name1);
            const norm2 = normalizeName(name2);
            
            if (!norm1 || !norm2) return 0;
            
            // Use multiple algorithms and take the best (like fuzzywuzzy)
            const tokenRatio = tokenSetRatio(norm1, norm2);
            const simpleRatio = calculateSimpleRatio(name1, name2);
            const partialRatio = calculatePartialRatio(norm1, norm2);
            
            // Return the weighted average, but penalize perfect matches when there were differences
            const bestRatio = Math.max(tokenRatio, simpleRatio, partialRatio);
            
            // If we got 100% but the original names were different, reduce the score
            if (bestRatio === 100 && name1.trim() !== name2.trim()) {
                return Math.min(95, bestRatio - 5); // Cap at 95% for non-identical names
            }
            
            return bestRatio;
        }
        
        // Token Set Ratio algorithm (similar to fuzzywuzzy)
        function tokenSetRatio(str1, str2) {
            const tokens1 = str1.split(/\s+/).filter(t => t.length > 0);
            const tokens2 = str2.split(/\s+/).filter(t => t.length > 0);
            
            if (tokens1.length === 0 || tokens2.length === 0) return 0;
            
            // Create sets of unique tokens
            const set1 = new Set(tokens1);
            const set2 = new Set(tokens2);
            
            // Find intersection
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            
            // Calculate similarity based on common tokens
            const commonTokens = [...intersection];
            const totalTokens = Math.max(tokens1.length, tokens2.length);
            
            if (commonTokens.length === 0) return 0;
            
            // Calculate ratio based on common tokens vs total tokens
            const commonRatio = (commonTokens.length / totalTokens) * 100;
            
            // Add bonus for exact token matches
            const exactMatches = tokens1.filter(token => tokens2.includes(token)).length;
            const exactBonus = (exactMatches / Math.max(tokens1.length, tokens2.length)) * 20;
            
            return Math.min(100, commonRatio + exactBonus);
        }
        
        // Calculate partial ratio (like fuzzywuzzy)
        function calculatePartialRatio(shorter, longer) {
            if (!shorter || !longer) return 0;
            
            const s = shorter.length <= longer.length ? shorter : longer;
            const l = shorter.length > longer.length ? shorter : longer;
            
            let bestRatio = 0;
            
            // Check all possible substrings of the longer string
            for (let i = 0; i <= l.length - s.length; i++) {
                const substring = l.substring(i, i + s.length);
                const ratio = calculateSimpleRatio(s, substring);
                bestRatio = Math.max(bestRatio, ratio);
            }
            
            return bestRatio;
        }
        
        // Calculate simple ratio (like fuzzywuzzy)
        function calculateSimpleRatio(str1, str2) {
            if (!str1 || !str2) return 0;
            
            const distance = levenshteinDistance(str1, str2);
            const maxLength = Math.max(str1.length, str2.length);
            
            if (maxLength === 0) return 100;
            
            return Math.round(((maxLength - distance) / maxLength) * 100);
        }
        
        // Levenshtein distance
        function levenshteinDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }
        
        // Process files
        function processFiles() {
            if (!unListData || !fileData) {
                alert('Please upload both UN_List and file to match');
                return;
            }
            
            const compareBtn = document.getElementById('compareBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            const progressFill = document.getElementById('progressFill');
            const statusText = document.getElementById('statusText');
            const resultsArea = document.getElementById('resultsArea');
            
            compareBtn.disabled = true;
            downloadBtn.disabled = true;
            statusText.textContent = 'Processing files...';
            resultsArea.textContent = '';
            
            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 5;
                progressFill.style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                    
                    // Perform real matching
                    const results = performRealMatching();
                    resultsArea.textContent = results.text;
                    processingResults = results.data;
                    
                    downloadBtn.disabled = false;
                    statusText.textContent = `Completed - ${results.data.highMatches.length} high matches, ${results.data.partialMatches.length} partial matches`;
                    
                    setTimeout(() => {
                        progressFill.style.width = '0%';
                        compareBtn.disabled = false;
                    }, 1000);
                }
            }, 100);
        }
        
        // Perform real matching
        function performRealMatching() {
            const threshold = parseInt(thresholdSlider.value);
            const highMatches = [];
            const partialMatches = [];
            const onlyInUNList = [];
            const onlyInFile = [];
            
            // Find name columns (try common column names)
            const unNameCol = findNameColumn(Object.keys(unListData[0] || {}), 'reference');
            const fileNameCol = findNameColumn(Object.keys(fileData[0] || {}), 'file');
            
            if (!unNameCol || !fileNameCol) {
                return {
                    text: '‚ùå Error: Could not find name columns in uploaded files. Please ensure your files have name columns.',
                    data: { highMatches: [], partialMatches: [], onlyInUNList: [], onlyInFile: [] }
                };
            }
            
            // Optimized matching with pre-computed normalized names and early exits
            const matchedUNIndices = new Set();
            const matchedFileIndices = new Set();
            
            // Pre-normalize all names for faster comparison (optimization 1)
            const normalizedUNNames = unListData.map(row => 
                normalizeName(String(row[unNameCol] || '').trim())
            );
            const normalizedFileNames = fileData.map(row => 
                normalizeName(String(row[fileNameCol] || '').trim())
            );
            
            // Match each file name against UN list with optimizations
            fileData.forEach((fileRow, fileIndex) => {
                if (matchedFileIndices.has(fileIndex)) return;
                
                const fileName = String(fileRow[fileNameCol] || '').trim();
                if (!fileName) return;
                
                const normalizedFileName = normalizedFileNames[fileIndex];
                if (!normalizedFileName) return;
                
                let bestMatch = null;
                let bestScore = 0;
                let bestUNIndex = -1;
                
                // Find best match in UN list (excluding already matched)
                unListData.forEach((unRow, unIndex) => {
                    if (matchedUNIndices.has(unIndex)) return;
                    
                    const unName = String(unRow[unNameCol] || '').trim();
                    if (!unName) return;
                    
                    // Optimization 2: Quick length check for early exit
                    const lenDiff = Math.abs(normalizedFileName.length - normalizedUNNames[unIndex].length);
                    if (lenDiff > Math.max(normalizedFileName.length, normalizedUNNames[unIndex].length) * 0.5) {
                        return; // Skip if length difference is too large
                    }
                    
                    // Optimization 3: Use pre-computed normalized names
                    const score = calculateSimilarity(normalizedFileName, normalizedUNNames[unIndex]);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = { unName, score, unRow, unIndex };
                    }
                });
                
                if (bestMatch && bestScore >= 50) {
                    // Mark both as matched
                    matchedUNIndices.add(bestMatch.unIndex);
                    matchedFileIndices.add(fileIndex);
                    
                    const matchData = {
                        fileName,
                        unName: bestMatch.unName,
                        score: bestScore.toFixed(1),
                        fileRow,
                        unRow: bestMatch.unRow
                    };
                    
                    if (bestScore >= threshold) {
                        highMatches.push(matchData);
                    } else {
                        partialMatches.push(matchData);
                    }
                }
            });
            
            // Find names only in UN list (not matched)
            unListData.forEach((unRow, index) => {
                if (!matchedUNIndices.has(index)) {
                    const unName = String(unRow[unNameCol] || '').trim();
                    if (unName) {
                        onlyInUNList.push({ name: unName, row: unRow });
                    }
                }
            });
            
            // Find names only in file (not matched)
            fileData.forEach((fileRow, index) => {
                if (!matchedFileIndices.has(index)) {
                    const fileName = String(fileRow[fileNameCol] || '').trim();
                    if (fileName) {
                        onlyInFile.push({ name: fileName, row: fileRow });
                    }
                }
            });
            
            // Generate results text (KEEP EXACTLY THE SAME FORMAT)
            let resultsText = `üéØ High Matches (‚â•${threshold}%): ${highMatches.length}\n`;
            resultsText += `üîç Partial Matches (<${threshold}%): ${partialMatches.length}\n`;
            resultsText += `üìã Total UN_List records: ${unListData.length}\n`;
            resultsText += `üìã Total file records: ${fileData.length}\n\n`;
            resultsText += `============================================================\n`;
            resultsText += `‚úÖ Processing completed successfully!\n\n`;
            
            if (highMatches.length > 0) {
                resultsText += `ü§ù HIGH CONFIDENCE MATCHES:\n`;
                resultsText += `--------------------------------------------------\n`;
                highMatches.slice(0, 15).forEach((match, index) => {
                    resultsText += `${index + 1}. ${match.fileName} ‚Üî ${match.unName} (Score: ${match.score}%)\n`;
                });
                if (highMatches.length > 15) {
                    resultsText += `... and ${highMatches.length - 15} more high matches\n`;
                }
                resultsText += `\n`;
            }
            
            if (partialMatches.length > 0) {
                resultsText += `üîç PARTIAL MATCHES (Below ${threshold}% threshold):\n`;
                resultsText += `--------------------------------------------------\n`;
                partialMatches.slice(0, 8).forEach((match, index) => {
                    resultsText += `${index + 1}. ${match.fileName} ‚Üî ${match.unName} (Score: ${match.score}%)\n`;
                });
                if (partialMatches.length > 8) {
                    resultsText += `... and ${partialMatches.length - 8} more partial matches\n`;
                }
                resultsText += `\n`;
            }
            
            resultsText += `============================================================`;
            
            return {
                text: resultsText,
                data: { highMatches, partialMatches, onlyInUNList, onlyInFile }
            };
        }
        
        // Find name column
        function findNameColumn(columns, fileType) {
            if (fileType === 'reference') {
                // Look for "FullName" in reference data
                for (const col of columns) {
                    if (col.toLowerCase() === 'fullname' || col.toLowerCase() === 'full_name') {
                        return col;
                    }
                }
                // Fallback to common name columns
                const nameKeywords = ['name', 'full_name', 'fullname', 'person', 'individual'];
                for (const keyword of nameKeywords) {
                    for (const col of columns) {
                        if (col.toLowerCase().includes(keyword)) {
                            return col;
                        }
                    }
                }
            } else {
                // Look for "Client Name" and "Surname" in file to match
                for (const col of columns) {
                    if (col.toLowerCase() === 'client name' || col.toLowerCase() === 'client_name') {
                        return col;
                    }
                }
                for (const col of columns) {
                    if (col.toLowerCase() === 'surname') {
                        return col;
                    }
                }
                // Fallback to common name columns
                const nameKeywords = ['client name', 'surname', 'name', 'full_name', 'fullname', 'person', 'customer'];
                for (const keyword of nameKeywords) {
                    for (const col of columns) {
                        if (col.toLowerCase().includes(keyword)) {
                            return col;
                        }
                    }
                }
            }
            
            // Return first column as fallback
            return columns[0];
        }
        
        // Download results
        function downloadResults() {
            if (!processingResults) {
                alert('No results to download');
                return;
            }
            
            try {
                // Check if XLSX library is loaded and working
                if (typeof XLSX === 'undefined') {
                    throw new Error('XLSX library not loaded. Please refresh the page and try again.');
                }
                
                // Test XLSX functionality
                if (typeof XLSX.utils !== 'object' || typeof XLSX.utils.book_new !== 'function') {
                    throw new Error('XLSX library not properly loaded. Please refresh the page.');
                }
                
                // Simple CSV export as primary option (more reliable)
                let csvContent = "Type,File Name,UN List Name,Match Score (%),Match Type\n";
                
                processingResults.highMatches.forEach((match, index) => {
                    csvContent += `High Match,"${(match.fileName || '').replace(/"/g, '""')}","${(match.unName || '').replace(/"/g, '""')}",${match.score || 0},High Confidence\n`;
                });
                
                processingResults.partialMatches.forEach((match, index) => {
                    csvContent += `Partial Match,"${(match.fileName || '').replace(/"/g, '""')}","${(match.unName || '').replace(/"/g, '""')}",${match.score || 0},Partial Match\n`;
                });
                
                // Create and download CSV file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sanction_screening_results_' + new Date().toISOString().slice(0,10) + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                // Try Excel as secondary option
                try {
                    const wb = XLSX.utils.book_new();
                    
                    if (processingResults.highMatches.length > 0) {
                        const highMatchesData = processingResults.highMatches.map((match, index) => ({
                            'No.': index + 1,
                            'File Name': match.fileName || '',
                            'UN List Name': match.unName || '',
                            'Match Score (%)': parseFloat(match.score) || 0,
                            'Match Type': 'High Confidence'
                        }));
                        
                        const wsHigh = XLSX.utils.json_to_sheet(highMatchesData);
                        XLSX.utils.book_append_sheet(wb, wsHigh, 'High Confidence Matches');
                    }
                    
                    if (processingResults.partialMatches.length > 0) {
                        const partialMatchesData = processingResults.partialMatches.map((match, index) => ({
                            'No.': index + 1,
                            'File Name': match.fileName || '',
                            'UN List Name': match.unName || '',
                            'Match Score (%)': parseFloat(match.score) || 0,
                            'Match Type': 'Partial Match'
                        }));
                        
                        const wsPartial = XLSX.utils.json_to_sheet(partialMatchesData);
                        XLSX.utils.book_append_sheet(wb, wsPartial, 'Partial Matches');
                    }
                    
                    const summaryData = [
                        { 'Metric': 'Total High Confidence Matches', 'Value': processingResults.highMatches.length },
                        { 'Metric': 'Total Partial Matches', 'Value': processingResults.partialMatches.length },
                        { 'Metric': 'Total Matches', 'Value': processingResults.highMatches.length + processingResults.partialMatches.length },
                        { 'Metric': 'Match Threshold Used', 'Value': (thresholdSlider.value || 80) + '%' },
                        { 'Metric': 'Processing Date', 'Value': new Date().toLocaleString() }
                    ];
                    
                    const wsSummary = XLSX.utils.json_to_sheet(summaryData);
                    XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');
                    
                    // Generate Excel file
                    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'binary' });
                    const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'sanction_screening_results_' + new Date().toISOString().slice(0,10) + '.xlsx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                } catch (excelError) {
                    console.warn('Excel export failed, CSV download successful:', excelError);
                }
                
            } catch (error) {
                console.error('Error creating download file:', error);
                console.error('Processing results:', processingResults);
                console.error('XLSX library available:', typeof XLSX !== 'undefined');
                console.error('XLSX utils available:', typeof XLSX.utils);
                
                alert('Error creating download file. CSV export was attempted. Please check console for details.');
            }
        }
    </script>
</body>
</html>
